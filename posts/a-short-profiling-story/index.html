<!doctype html><html lang=en><head><title>A Short Profiling Story ::
Claudio Ortolina — My personal website</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="While transcribing the talk I gave at the last ElixirConf.eu conference, one of my colleagues pointed out that I glossed over the details of one of the examples. This prompted me to do some digging and I want to share what I found.
The problem   The example in question is a module responsible to fetch a file from a remote source and write it at the specified path."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=http://claudio-ortolina.org/posts/a-short-profiling-story/><link rel=stylesheet href=http://claudio-ortolina.org/assets/style.css><link rel=stylesheet href=http://claudio-ortolina.org/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=http://claudio-ortolina.org/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=http://claudio-ortolina.org/img/favicon.png><link href=http://claudio-ortolina.org/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=http://claudio-ortolina.org/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=http://claudio-ortolina.org/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=http://claudio-ortolina.org/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=http://claudio-ortolina.org/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=http://claudio-ortolina.org/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="A Short Profiling Story"><meta name=twitter:description content="Using profiling tools to understand and debug memory usage"><meta property="og:title" content="A Short Profiling Story"><meta property="og:description" content="Using profiling tools to understand and debug memory usage"><meta property="og:type" content="article"><meta property="og:url" content="http://claudio-ortolina.org/posts/a-short-profiling-story/"><meta property="article:published_time" content="2020-11-03T11:42:42+00:00"><meta property="article:modified_time" content="2020-11-03T11:42:42+00:00"><meta property="og:site_name" content="Claudio Ortolina"></head><body><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Claudio Ortolina</span>
<span class=logo__cursor></span></a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/talks>Talks</a></li><li><a href=https://github.com/cloud8421/claudio-ortolina.org>Source</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/talks>Talks</a></li><li><a href=https://github.com/cloud8421/claudio-ortolina.org>Source</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>A Short Profiling Story</h1><div class=post-meta><span class=post-date>2020-11-03</span>
<span class=post-read-time>— 3 min read</span></div><span class=post-tags><a href=http://claudio-ortolina.org/tags/elixir/>#elixir</a>&nbsp;
<a href=http://claudio-ortolina.org/tags/software-development/>#software development</a>&nbsp;</span><div class=post-content><p>While transcribing
<a href=https://www.elixirconf.eu/talks/The-Perils-of-Large-Files/>the talk I
gave at the last ElixirConf.eu</a> conference, one of my colleagues
pointed out that I glossed over the details of one of the examples. This
prompted me to do some digging and I want to share what I found.</p><div id=outline-container-the-problem class=outline-3><h3 id=the-problem>The problem</h3><div id=outline-text-the-problem class=outline-text-3><p>The example in question is a module responsible to fetch a file from a
remote source and write it at the specified path.</p><p>The implementation is very simplistic and lacks both error handling and
retry logic.</p><div class="src src-elixir"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir>  <span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>Perils.Examples.Store</span> <span style=color:#66d9ef>do</span>
     <span style=color:#66d9ef>def</span> write(file_name, url) <span style=color:#66d9ef>do</span>
       with {<span style=color:#e6db74>:ok</span>, data} <span style=color:#f92672>&lt;-</span> get(url) <span style=color:#66d9ef>do</span>
         <span style=color:#a6e22e>File</span><span style=color:#f92672>.</span>write!(file_name, data)
       <span style=color:#66d9ef>end</span>
     <span style=color:#66d9ef>end</span>

     <span style=color:#66d9ef>defp</span> get(url) <span style=color:#66d9ef>do</span>
       <span style=color:#e6db74>:httpc</span><span style=color:#f92672>.</span>request(<span style=color:#e6db74>:get</span>, {<span style=color:#a6e22e>String</span><span style=color:#f92672>.</span>to_charlist(url), []}, [], [])
       <span style=color:#f92672>|&gt;</span> <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>do</span>
         {<span style=color:#e6db74>:ok</span>, result} <span style=color:#f92672>-&gt;</span>
           {{_, <span style=color:#ae81ff>200</span>, _}, _headers, body} <span style=color:#f92672>=</span> result
           {<span style=color:#e6db74>:ok</span>, body}

         error <span style=color:#f92672>-&gt;</span>
           error
       <span style=color:#66d9ef>end</span>
     <span style=color:#66d9ef>end</span>
   <span style=color:#66d9ef>end</span></code></pre></div></div><p>Looking at the code, we can see that it relies on <code class=verbatim>:httpc</code>, the http
client that ships with Erlang/OTP.</p><p>Both in my talk and in the initial transcription draft, I pointed out
that running this code with a 12MB file would result in a memory usage
peak at around 350/375MB, but didn't really look into why.</p><p><img src=/img/a-short-profiling-story/before.png alt="A chart visualizing a 350MB memory spike" class=left></p><p>Such delta between the file size and peak memory usage is suspicious and
worth investigating.</p></div></div><div id=outline-container-the-investigation class=outline-3><h3 id=the-investigation>The investigation</h3><div id=outline-text-the-investigation class=outline-text-3><p>I started by setting up an <a href=https://github.com/parroty/exprof>exprof</a>
test, so that I could profile resource usage associated with the
problematic function.</p><div class="src src-elixir"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir>  <span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>A</span> <span style=color:#66d9ef>do</span>
    <span style=color:#f92672>import</span> <span style=color:#a6e22e>ExProf.Macro</span>

    <span style=color:#66d9ef>def</span> run(url) <span style=color:#66d9ef>do</span>
      profile <span style=color:#66d9ef>do</span>
        <span style=color:#a6e22e>Perils.Examples.Store</span><span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;magazine.pdf&#34;</span>, url)
      <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>end</span>
  <span style=color:#66d9ef>end</span>

  url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://web-examples.pspdfkit.com/magazine/example.pdf&#34;</span> <span style=color:#75715e>#12MB</span>
  {records, _block_result} <span style=color:#f92672>=</span> <span style=color:#a6e22e>A</span><span style=color:#f92672>.</span>run(url)
  total_percent <span style=color:#f92672>=</span> <span style=color:#a6e22e>Enum</span><span style=color:#f92672>.</span>reduce(records, <span style=color:#ae81ff>0.0</span>, <span style=color:#f92672>&amp;</span>(&amp;1<span style=color:#f92672>.</span>percent <span style=color:#f92672>+</span> &amp;2))
  <span style=color:#a6e22e>IO</span><span style=color:#f92672>.</span>inspect(<span style=color:#e6db74>&#34;total = </span><span style=color:#e6db74>#{</span>total_percent<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)</code></pre></div></div><p>The result (with some lines omitted) shows that most of the time
(51.74%) is spent converting the binary response body to a list inside
the <code class=verbatim>maybe_format_body/2</code> function:</p><pre class=example>
  FUNCTION                                             CALLS        %    TIME  [uS / CALLS]
  --------                                             -----  -------    ----  [----------]
  &lt;omitted&gt;
  erlang:iolist_to_binary/1                                1    20.46   49705  [  49705.00]
  erlang:binary_to_list/1                                  1    27.54   66887  [  66887.00]
  httpc:maybe_format_body/2                                1    51.74  125664  [ 125664.00]
</pre><p>While this is not an indication of higher memory usage per se, it's a
good lead: binary to list conversion can be memory intensive.</p><p>I then looked at the
<a href=https://github.com/erlang/otp/blob/3f21ce1e6a5d6c548867fa4bc9a8c666c626ade1/lib/inets/src/http_client/httpc.erl#L655-L661>source
for <code class=verbatim>maybe_format_body/2</code></a>, making sure to match on the OTP version I
tested against (23.1.1).</p><div class="src src-erlang"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-erlang data-lang=erlang>  maybe_format_body(BinBody, Options) <span style=color:#f92672>-&gt;</span>
      <span style=color:#66d9ef>case</span> proplists:<span style=color:#a6e22e>get_value</span>(body_format, Options, string) <span style=color:#66d9ef>of</span>
           string <span style=color:#f92672>-&gt;</span>
               binary_to_list(BinBody);
           _ <span style=color:#f92672>-&gt;</span>
               BinBody
      <span style=color:#66d9ef>end</span>.</code></pre></div></div><p>As expected, the function uses <code class=verbatim>binary_to_list/1</code> to transform the
response binary body into a list. Luckily, this behaviour can be tweaked
via the <code class=verbatim>body_format</code> option, which defaults to <code class=verbatim>string</code> (as in Erlang
string, which maps to a character list in Elixir).</p><p>Searching for <code class=verbatim>body_format</code> in
<a href=http://erlang.org/doc/man/httpc.html#request-5>the Erlang docs for
<code class=verbatim>request/5</code></a> shows that indeed it's possible to tweak our problematic
implementation to:</p><div class="src src-elixir"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir>  <span style=color:#e6db74>:httpc</span><span style=color:#f92672>.</span>request(<span style=color:#e6db74>:get</span>, {<span style=color:#a6e22e>String</span><span style=color:#f92672>.</span>to_charlist(url), []}, [], <span style=color:#e6db74>body_format</span>: <span style=color:#e6db74>:binary</span>)</code></pre></div></div><p>With this change, memory usage decreases dramatically, showing a delta
only slightly larger than the file size.</p><p><img src=/img/a-short-profiling-story/after.png alt="A chart visualizing a 15MB memory spike" class=left></p></div></div><div id=outline-container-conclusion class=outline-3><h3 id=conclusion>Conclusion</h3><div id=outline-text-conclusion class=outline-text-3><p>This whole investigation got me thinking, as the <code class=verbatim>body_format</code> option
had been in the docs all along, yet I hadn't seen it. I can find three
reasons:</p><ol><li><p>The overall logic in the example doesn't really care about the
response body contents, as it just writes them to a file. Without
seeing that response, there was no way for me to even notice its
type.</p></li><li><p><code class=verbatim>File.write/2</code> accepts binaries, strings and character lists - again
I didn't have a reason to even wonder about the type used to
represent that returned response body.</p></li><li><p>Working primarily in Elixir, everything tends to be either a string
or a binary. I just "forget" that character lists exist, which lead
to the implicit assumption that this would be the default for
<code class=verbatim>:httpc</code>.</p></li></ol><p>In other words, I didn't know what to search in the docs. Profiling
tools helped me understand the problem space and pointed me in the right
direction.</p></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=http://claudio-ortolina.org/posts/one-on-one-notes/><span class=button__icon>←</span>
<span class=button__text>Remote 1-on-1 meetings</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user">Copyright 2020 © Claudio Ortolina</div></div></footer><script src=http://claudio-ortolina.org/assets/main.js></script><script src=http://claudio-ortolina.org/assets/prism.js></script><script src=https://getinsights.io/js/insights.js></script><script>insights.init('chnDdvwnTlzrXc_B');insights.trackPages();</script></div></body></html>