<!doctype html><html lang=en><head><title>A Short Profiling Story :: Claudio Ortolina</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="While transcribing the talk I gave at the last ElixirConf.eu conference, one of my colleagues pointed out that I glossed over the details of one of the examples. This prompted me to do some digging and I want to share what I found.
The problem The example in question is a module responsible to fetch a file from a remote source and write it at the specified path.
The implementation is very simplistic and lacks both error handling and retry logic."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=http://claudio-ortolina.org/posts/a-short-profiling-story/><link rel=stylesheet href=http://claudio-ortolina.org/assets/style.css><link rel=apple-touch-icon href=http://claudio-ortolina.org/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=http://claudio-ortolina.org/img/favicon/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="A Short Profiling Story"><meta property="og:description" content="Using profiling tools to understand and debug memory usage"><meta property="og:url" content="http://claudio-ortolina.org/posts/a-short-profiling-story/"><meta property="og:site_name" content="Claudio Ortolina"><meta property="og:image" content="http://claudio-ortolina.org/img/favicon/orange.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-11-03 11:42:42 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Claudio Ortolina</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/talks>Talks</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/talks>Talks</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=http://claudio-ortolina.org/posts/a-short-profiling-story/>A Short Profiling Story</a></h1><div class=post-meta><span class=post-date>2020-11-03</span></div><span class=post-tags>#<a href=http://claudio-ortolina.org/tags/elixir/>elixir</a>&nbsp;
#<a href=http://claudio-ortolina.org/tags/software-development/>software development</a>&nbsp;</span><div class=post-content><div><p>While transcribing <a href=https://www.elixirconf.eu/talks/The-Perils-of-Large-Files/>the talk I gave at the last ElixirConf.eu</a> conference, one of my colleagues pointed out that I glossed over the details of one of the examples. This prompted me to do some digging and I want to share what I found.</p><h2 id=the-problem>The problem<a href=#the-problem class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The example in question is a module responsible to fetch a file from a remote source and write it at the specified path.</p><p>The implementation is very simplistic and lacks both error handling and retry logic.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir>defmodule <span style=color:#a6e22e>Perils.Examples.Store</span> do
   def write(file_name, url) do
     with {<span style=color:#e6db74>:ok</span>, data} <span style=color:#f92672>&lt;-</span> get(url) do
       <span style=color:#a6e22e>File</span><span style=color:#f92672>.</span>write!(file_name, data)
     end
   end

   defp get(url) do
     <span style=color:#e6db74>:httpc</span><span style=color:#f92672>.</span>request(<span style=color:#e6db74>:get</span>, {<span style=color:#a6e22e>String</span><span style=color:#f92672>.</span>to_charlist(url), []}, [], [])
     <span style=color:#f92672>|&gt;</span> case do
       {<span style=color:#e6db74>:ok</span>, result} <span style=color:#f92672>-&gt;</span>
         {{_, <span style=color:#ae81ff>200</span>, _}, _headers, body} <span style=color:#f92672>=</span> result
         {<span style=color:#e6db74>:ok</span>, body}

       error <span style=color:#f92672>-&gt;</span>
         error
     end
   end
 end
</code></pre></div><p>Looking at the code, we can see that it relies on <code>:httpc</code>, the http client that ships with Erlang/OTP.</p><p>Both in my talk and in the initial transcription draft, I pointed out that running this code with a 12MB file would result in a memory usage peak at around 350/375MB, but didn&rsquo;t really look into why.</p><img src=/img/a-short-profiling-story/before.png alt="A chart visualizing a 350MB memory spike" class=left><p>Such delta between the file size and peak memory usage is suspicious and worth investigating.</p><h2 id=the-investigation>The investigation<a href=#the-investigation class=hanchor arialabel=Anchor>&#8983;</a></h2><p>I started by setting up an <a href=https://github.com/parroty/exprof>exprof</a> test, so that I could profile resource usage associated with the problematic function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir>defmodule <span style=color:#a6e22e>A</span> do
  import <span style=color:#a6e22e>ExProf.Macro</span>

  def run(url) do
    profile do
      <span style=color:#a6e22e>Perils.Examples.Store</span><span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;magazine.pdf&#34;</span>, url)
    end
  end
end

url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://web-examples.pspdfkit.com/magazine/example.pdf&#34;</span> <span style=color:#75715e>#12MB</span>
{records, _block_result} <span style=color:#f92672>=</span> <span style=color:#a6e22e>A</span><span style=color:#f92672>.</span>run(url)
total_percent <span style=color:#f92672>=</span> <span style=color:#a6e22e>Enum</span><span style=color:#f92672>.</span>reduce(records, <span style=color:#ae81ff>0.0</span>, <span style=color:#f92672>&amp;</span>(&amp;1<span style=color:#f92672>.</span>percent <span style=color:#f92672>+</span> &amp;2))
<span style=color:#a6e22e>IO</span><span style=color:#f92672>.</span>inspect(<span style=color:#e6db74>&#34;total = </span><span style=color:#e6db74>#{</span>total_percent<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><p>The result (with some lines omitted) shows that most of the time (51.74%) is spent converting the binary response body to a list inside the <code>maybe_format_body/2</code> function:</p><pre><code>FUNCTION                                             CALLS        %    TIME  [uS / CALLS]
--------                                             -----  -------    ----  [----------]
&lt;omitted&gt;
erlang:iolist_to_binary/1                                1    20.46   49705  [  49705.00]
erlang:binary_to_list/1                                  1    27.54   66887  [  66887.00]
httpc:maybe_format_body/2                                1    51.74  125664  [ 125664.00]
</code></pre><p>While this is not an indication of higher memory usage per se, it&rsquo;s a good lead: binary to list conversion can be memory intensive.</p><p>I then looked at the <a href=https://github.com/erlang/otp/blob/3f21ce1e6a5d6c548867fa4bc9a8c666c626ade1/lib/inets/src/http_client/httpc.erl#L655-L661>source for <code>maybe_format_body/2</code></a>, making sure to match on the OTP version I tested against (23.1.1).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-erlang data-lang=erlang><span style=color:#a6e22e>maybe_format_body</span>(BinBody, Options) <span style=color:#f92672>-&gt;</span>
    <span style=color:#66d9ef>case</span> proplists:<span style=color:#a6e22e>get_value</span>(body_format, Options, string) <span style=color:#66d9ef>of</span>
	     string <span style=color:#f92672>-&gt;</span>
	         binary_to_list(BinBody);
	     _ <span style=color:#f92672>-&gt;</span>
	         BinBody
    <span style=color:#66d9ef>end</span>.
</code></pre></div><p>As expected, the function uses <code>binary_to_list/1</code> to transform the response binary body into a list. Luckily, this behaviour can be tweaked via the <code>body_format</code> option, which defaults to <code>string</code> (as in Erlang string, which maps to a character list in Elixir).</p><p>Searching for <code>body_format</code> in <a href=http://erlang.org/doc/man/httpc.html#request-5>the Erlang docs for <code>request/5</code></a> shows that indeed it&rsquo;s possible to tweak our problematic implementation to:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#e6db74>:httpc</span><span style=color:#f92672>.</span>request(<span style=color:#e6db74>:get</span>, {<span style=color:#a6e22e>String</span><span style=color:#f92672>.</span>to_charlist(url), []}, [], <span style=color:#e6db74>body_format</span>: <span style=color:#e6db74>:binary</span>)
</code></pre></div><p>With this change, memory usage decreases dramatically, showing a delta only slightly larger than the file size.</p><img src=/img/a-short-profiling-story/after.png alt="A chart visualizing a 15MB memory spike" class=left><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This whole investigation got me thinking, as the <code>body_format</code> option had been in the docs all along, yet I hadn&rsquo;t seen it. I can find three reasons:</p><ol><li>The overall logic in the example doesn&rsquo;t really care about the response body contents, as it just writes them to a file. Without seeing that response, there was no way for me to even notice its type.</li><li><code>File.write/2</code> accepts binaries, strings and character lists - again I didn&rsquo;t have a reason to even wonder about the type used to represent that returned response body.</li><li>Working primarily in Elixir, everything tends to be either a string or a binary. I just &ldquo;forget&rdquo; that character lists exist, which lead to the implicit assumption that this would be the default for <code>:httpc</code>.</li></ol><p>In other words, I didn&rsquo;t know what to search in the docs. Profiling tools helped me understand the problem space and pointed me in the right direction.</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2020 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=http://claudio-ortolina.org/assets/main.js></script><script src=http://claudio-ortolina.org/assets/prism.js></script></div></body></html>