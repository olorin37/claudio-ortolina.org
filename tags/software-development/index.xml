<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>software development on Claudio Ortolina</title><link>http://claudio-ortolina.org/tags/software-development/</link><description>Recent content in software development on Claudio Ortolina</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><copyright> &lt;p xmlns:dct="http://purl.org/dc/terms/" xmlns:cc="http://creativecommons.org/ns#" class="license-text">&lt;a rel="cc:attributionURL" property="dct:title" href="https://claudio-ortolina.org">This website&lt;/a> by &lt;a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://claudio-ortolina.org">Claudio Ortolina&lt;/a> is licensed under &lt;a rel="license" href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0&lt;/a>&lt;/p></copyright><lastBuildDate>Sat, 21 Nov 2020 09:29:01 +0000</lastBuildDate><atom:link href="http://claudio-ortolina.org/tags/software-development/index.xml" rel="self" type="application/rss+xml"/><item><title>Building a Custom Page for Phoenix Live Dashboard</title><link>http://claudio-ortolina.org/posts/building-a-custom-page-for-phoenix-live-dashboard/</link><pubDate>Sat, 21 Nov 2020 09:29:01 +0000</pubDate><guid>http://claudio-ortolina.org/posts/building-a-custom-page-for-phoenix-live-dashboard/</guid><description>
&lt;p>
One of the most interesting features provided by Phoenix Live Dashboard is the ability to &lt;a href="https://hexdocs.pm/phoenix_live_dashboard/Phoenix.LiveDashboard.PageBuilder.html#content">define your own pages&lt;/a>, so that you can quickly and reliably extend a Live Dashboard instance with sections that are tailored to your application domain.&lt;/p>
&lt;p>
While working on &lt;a href="https://github.com/fully-forged/tune">Tune&lt;/a>, I found a use case suitable for a custom live dashboard page: a debugging view where I can check open sessions and inspect the underlying processes.&lt;/p>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
On the use case
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
I would encourage you to read &lt;a href="https://github.com/fully-forged/tune">Tune&amp;#39;s README&lt;/a> to understand the use case in more detail, but I&amp;#39;ll quote the relevant architectural section:&lt;/p>
&lt;blockquote>
&lt;p>Tune assumes multiple browser sessions for the same user, which is why it defines a &lt;a href="https://tune-docs.fullyforged.com/Tune.Spotify.Session.html#content">&lt;code>Tune.Spotify.Session&lt;/code>&lt;/a> behaviour with &lt;a href="https://tune-docs.fullyforged.com/Tune.Spotify.Session.HTTP.html#content">&lt;code>Tune.Spotify.Session.HTTP&lt;/code>&lt;/a> as its main runtime implementation.&lt;/p>
&lt;p>
Each worker is responsible to proxy interaction with the Spotify API, periodically poll for data changes, and broadcast corresponding events.&lt;/p>
&lt;p>
When a user opens a browser session, &lt;a href="https://tune-docs.fullyforged.com/TuneWeb.ExplorerLive.html#content">&lt;code>TuneWeb.ExplorerLive&lt;/code>&lt;/a> either starts or simply reuses a worker named with the same session ID.&lt;/p>
&lt;p>
Each worker monitors its subscribers, so that it can shutdown when a user closes their last browser window.&lt;/p>
&lt;p>
This architecture ensures that:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The amount of automatic API calls against the Spotify API for a given user is constant and independent from the number of user sessions for the same user.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Credential renewal happens in the background&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The explorer implementation remains entirely focused on UI interaction&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>
In other words:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>For each Spotify account connected, there can only be one session (a &lt;code>Tune.Spotify.Session.HTTP&lt;/code> process named with the session ID).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>For each session, there can be many open clients (i.e. browser windows or &lt;code>TuneWeb.ExplorerLive&lt;/code> process).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-2" class="outline-2">
&lt;h2 id="headline-2">
Requirements
&lt;/h2>
&lt;div id="outline-text-headline-2" class="outline-text-2">
&lt;p>
Our dashboard page will include:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A table with session IDs, PIDs and count of open clients&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ability to sort by session ID or clients count&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Search by session ID&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Support multiple nodes&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-2">
&lt;h2 id="headline-3">
Gathering the necessary data
&lt;/h2>
&lt;div id="outline-text-headline-3" class="outline-text-2">
&lt;p>
To populate the dashboard table, we first need to find a way to get a list of all active sessions, along with their clients count.&lt;/p>
&lt;p>
The simplest way is to leverage the fact that each &lt;code>Tune.Spotify.Session.HTTP&lt;/code> process is started with a name managed via a &lt;a href="https://hexdocs.pm/elixir/Registry.html">Registry&lt;/a>, with the session ID as a key. Registration is in place to guarantee that there can only be one session process with the same ID on each node.&lt;/p>
&lt;p>
We can use &lt;a href="https://hexdocs.pm/elixir/Registry.html#select/2">&lt;code>Registry.select/2&lt;/code>&lt;/a> to query the registry and receive back all session IDs and PIDs:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#a6e22e">Registry&lt;/span>&lt;span style="color:#f92672">.&lt;/span>select(
&lt;span style="color:#a6e22e">Tune.Spotify.SessionRegistry&lt;/span>,
[{{&lt;span style="color:#e6db74">:&amp;#34;$1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:&amp;#34;$2&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:_&lt;/span>}, [], [{{&lt;span style="color:#e6db74">:&amp;#34;$1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:&amp;#34;$2&amp;#34;&lt;/span>}}]}]
)&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
Which returns:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">[{&lt;span style="color:#e6db74">&amp;#34;claudio.ortolina&amp;#34;&lt;/span>, &lt;span style="color:#75715e">#PID&amp;lt;0.565.0&amp;gt;}]&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
In the example above, we use a match specification to capture the registry key (the session ID) and the registered PID.&lt;/p>
&lt;p>
It&amp;#39;s important to understand straight away the constraints associated with this approach:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A &lt;code>Registry&lt;/code> is normally split into a variable number of partitions, so this query has to visit all partitions to return its results. While this is not a problem at this stage (the application has very little load), it can become a bottleneck once the number of registered processes grows.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>As data is partitioned, it&amp;#39;s not possible to apply sort order or limit the results without concatenating them all first, which means that both operations will need to be done by the caller.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Results only apply to the current node, which works well with Phoenix Live Dashboard&amp;#39;s general structure, which always operates on one node at a time.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Given the registry query above, we can implement a function that provides the data necessary to populate an unfiltered, unsorted version of the table:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">Tune.Spotify.Supervisor&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#75715e"># omitted&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> sessions &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#a6e22e">Tune.Spotify.SessionRegistry&lt;/span>
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Registry&lt;/span>&lt;span style="color:#f92672">.&lt;/span>select([{{&lt;span style="color:#e6db74">:&amp;#34;$1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:&amp;#34;$2&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:_&lt;/span>}, [], [{{&lt;span style="color:#e6db74">:&amp;#34;$1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:&amp;#34;$2&amp;#34;&lt;/span>}}]}])
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>map(&lt;span style="color:#66d9ef">fn&lt;/span> {id, pid} &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
subscribers_count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Tune.Spotify.Session.HTTP&lt;/span>&lt;span style="color:#f92672">.&lt;/span>subscribers_count(id)
%{&lt;span style="color:#e6db74">id&lt;/span>: id, &lt;span style="color:#e6db74">pid&lt;/span>: pid, &lt;span style="color:#e6db74">clients_count&lt;/span>: subscribers_count}
&lt;span style="color:#66d9ef">end&lt;/span>)
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
The resulting data structure is a map with the necessary data:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">[%{&lt;span style="color:#e6db74">clients_count&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;claudio.ortolina&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">pid&lt;/span>: &lt;span style="color:#75715e">#PID&amp;lt;0.565.0&amp;gt;}]&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-2">
&lt;h2 id="headline-4">
Dashboard page structure
&lt;/h2>
&lt;div id="outline-text-headline-4" class="outline-text-2">
&lt;p>
To build a dashboard page, we need to:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Create a module that implements the &lt;code>use Phoenix.LiveDashboard.PageBuilder&lt;/code> behaviour.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mount that module into the Live Dashboard configuration defined into our application router.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>What follows is a minimal implementation that shows the data we need, with the following limitations:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>no searching, sorting or limiting capabilities&lt;/p>
&lt;/li>
&lt;li>
&lt;p>works only on a single node&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">TuneWeb.LiveDashboard.SpotifySessionsPage&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#a6e22e">@moduledoc&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;span style="color:#f92672">use&lt;/span> &lt;span style="color:#a6e22e">Phoenix.LiveDashboard.PageBuilder&lt;/span>
&lt;span style="color:#a6e22e">@impl&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> menu_link(_, _) &lt;span style="color:#66d9ef">do&lt;/span>
{&lt;span style="color:#e6db74">:ok&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Spotify Sessions&amp;#34;&lt;/span>}
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#a6e22e">@impl&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> render_page(_assigns) &lt;span style="color:#66d9ef">do&lt;/span>
table(
&lt;span style="color:#e6db74">columns&lt;/span>: columns(),
&lt;span style="color:#e6db74">id&lt;/span>: &lt;span style="color:#e6db74">:spotify_sessions&lt;/span>,
&lt;span style="color:#e6db74">row_attrs&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>row_attrs&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,
&lt;span style="color:#e6db74">row_fetcher&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>fetch_sessions&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>,
&lt;span style="color:#e6db74">rows_name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;sessions&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Spotify Sessions&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> fetch_sessions(_params, _node) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#75715e"># returns [%{clients_count: 1, id: &amp;#34;claudio.ortolina&amp;#34;, pid: #PID&amp;lt;0.565.0&amp;gt;}]&lt;/span>
sessions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Tune.Spotify.Supervisor&lt;/span>&lt;span style="color:#f92672">.&lt;/span>sessions()
{sessions, length(sessions)}
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> columns &lt;span style="color:#66d9ef">do&lt;/span>
[
%{&lt;span style="color:#e6db74">field&lt;/span>: &lt;span style="color:#e6db74">:id&lt;/span>, &lt;span style="color:#e6db74">header&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Session ID&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">sortable&lt;/span>: &lt;span style="color:#e6db74">:asc&lt;/span>},
%{
&lt;span style="color:#e6db74">field&lt;/span>: &lt;span style="color:#e6db74">:pid&lt;/span>,
&lt;span style="color:#e6db74">header&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Worker PID&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">format&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>(&amp;amp;1 &lt;span style="color:#f92672">|&amp;gt;&lt;/span> encode_pid() &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>replace_prefix(&lt;span style="color:#e6db74">&amp;#34;PID&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>))
},
%{&lt;span style="color:#e6db74">field&lt;/span>: &lt;span style="color:#e6db74">:clients_count&lt;/span>, &lt;span style="color:#e6db74">header&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Clients count&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">sortable&lt;/span>: &lt;span style="color:#e6db74">:asc&lt;/span>}
]
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> row_attrs(session) &lt;span style="color:#66d9ef">do&lt;/span>
[
{&lt;span style="color:#e6db74">&amp;#34;phx-click&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;show_info&amp;#34;&lt;/span>},
{&lt;span style="color:#e6db74">&amp;#34;phx-value-info&amp;#34;&lt;/span>, encode_pid(session[&lt;span style="color:#e6db74">:pid&lt;/span>])},
{&lt;span style="color:#e6db74">&amp;#34;phx-page-loading&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>}
]
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
The main ingredients of this implementation are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The &lt;code>use Phoenix.LiveDashboard.PageBuilder&lt;/code> directive, which adopts the behaviour with the same name and imports some convenience functions useful for building pages (e.g. &lt;code>encode_pid/1&lt;/code>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The &lt;code>menu_link/2&lt;/code> callback, which is used to define the name of the page and its label in the top navigation bar.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The &lt;code>render_page/2&lt;/code> callback, which has to return a valid &lt;a href="https://hexdocs.pm/phoenix_live_dashboard/Phoenix.LiveDashboard.PageBuilder.html#t:component/0">&lt;code>component&lt;/code>&lt;/a> - in this case via the &lt;a href="https://hexdocs.pm/phoenix_live_dashboard/Phoenix.LiveDashboard.PageBuilder.html#table/1">&lt;code>table/1&lt;/code>&lt;/a> function.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The table definition has a few moving parts:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>An &lt;code>id&lt;/code> (unique among other Live Dashboard pages).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A &lt;code>title&lt;/code>, shown in the page.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A &lt;code>rows_name&lt;/code>, interpolated in the short text blurb that details the total amount of results.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A &lt;code>columns&lt;/code> attribute, which is a list of maps detailing the properties of each column.&lt;/p>
&lt;p>
For each column, the &lt;code>id&lt;/code> property has to map to a key in the data we will use to populate the table.&lt;/p>
&lt;p>
The &lt;code>sortable&lt;/code> property defines which column can be used for sorting (by clicking on the header chevron). Note that unless you specify a &lt;code>default_sort_by&lt;/code> attribute for the entire table, you have to have at least one column with the &lt;code>sortable&lt;/code> property defined, otherwise you will get a compile error.&lt;/p>
&lt;p>
The &lt;code>format&lt;/code> function takes the raw value for a cell in the column and transforms it to a string. It&amp;#39;s useful to provide a string representation of the value that is suitable for an HTML table. In the code above, we copy the format function defined in &lt;a href="https://github.com/phoenixframework/phoenix_live_dashboard/blob/8d7148d9c333a27766ee8bc971d4dba93c0f9695/lib/phoenix/live_dashboard/pages/processes_page.ex#L34">the Processes Live Dashboard page&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A &lt;code>row_attrs&lt;/code> function, which takes the data for each row and has to return a list of tuples representing the Phoenix LiveView attributes to apply to the table row itself. Defining attribute is necessary to enable functionality activated by clicking on the row itself. The implementation in this example lets you inspect the session PID in a modal overlay.&lt;/p>
&lt;p>
Similar to the &lt;code>format&lt;/code> function, we leverage &lt;code>encode_pid/1&lt;/code> to format the PID as string compatible with the &lt;code>show_info&lt;/code> LiveView event.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A &lt;code>row_fetcher&lt;/code> function, which takes the current &lt;code>params&lt;/code> (search query, limit, sort key, sort direction) and the current node, and returns the data used to populate the table.&lt;/p>
&lt;p>
The return value has to conform to a tuple shape where the first value is a list of sessions (in the shape of maps with the same keys used for column ids) and the second value is the total number of results (irrespectively of the limit).&lt;/p>
&lt;p>
As we implemented &lt;code>Tune.Spotify.Supervisor.sessions/0&lt;/code> taking care of using the same key names, its return value perfectly fits the expectations of the &lt;code>row_fetcher&lt;/code> function.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-2">
&lt;h2 id="headline-5">
Mounting the dashboard page
&lt;/h2>
&lt;div id="outline-text-headline-5" class="outline-text-2">
&lt;p>
To have the page up and running, we need to modify the &lt;code>live_dashboard/2&lt;/code> function inside the application router:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">live_dashboard &lt;span style="color:#e6db74">&amp;#34;/dashboard&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">metrics&lt;/span>: &lt;span style="color:#a6e22e">TuneWeb.Telemetry&lt;/span>,
&lt;span style="color:#e6db74">metrics_history&lt;/span>: {&lt;span style="color:#a6e22e">TuneWeb.Telemetry.Storage&lt;/span>, &lt;span style="color:#e6db74">:metrics_history&lt;/span>, []},
&lt;span style="color:#e6db74">additional_pages&lt;/span>: [
&lt;span style="color:#e6db74">spotify_sessions&lt;/span>: &lt;span style="color:#a6e22e">TuneWeb.LiveDashboard.SpotifySessionsPage&lt;/span>
]&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-2">
&lt;h2 id="headline-6">
Filters and limits
&lt;/h2>
&lt;div id="outline-text-headline-6" class="outline-text-2">
&lt;p>
We can now focus on implementing search, sorting and limits. Conceptually, we need to:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>If specified, apply the search filter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Always apply sort order.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Count the sorted elements, to return the correct total.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Always apply the limit clause to the sorted elements.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>All of these operations have to be handled by the implementation of the &lt;code>row_fetcher&lt;/code> function.&lt;/p>
&lt;p>
The params map has the following keys:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>:search&lt;/code>: the string representing the contents of the search input (or &lt;code>nil&lt;/code> when empty).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>:sort_by&lt;/code>: the id of the column to sort by.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>:sort_dir&lt;/code>: the sort direction, expressed with the atoms &lt;code>:asc&lt;/code> and &lt;code>:desc&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>:limit&lt;/code>: the integer value representing the amount of max items requested by the user.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The params map is very well thought out, as it has a fixed structure, applied defaults where available and values that play well with functions from the &lt;code>Enum&lt;/code> module.&lt;/p>
&lt;p>
We can extend the &lt;code>fetch_sessions/2&lt;/code> function as follows:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">TuneWeb.LiveDashboard.SpotifySessionsPage&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#75715e"># omitted&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> fetch_sessions(params, _node) &lt;span style="color:#66d9ef">do&lt;/span>
sessions &lt;span style="color:#f92672">=&lt;/span>
&lt;span style="color:#a6e22e">Tune.Spotify.Supervisor&lt;/span>&lt;span style="color:#f92672">.&lt;/span>sessions()
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> filter(params)
{&lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>take(sessions, params[&lt;span style="color:#e6db74">:limit&lt;/span>]), length(sessions)}
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> filter(sessions, params) &lt;span style="color:#66d9ef">do&lt;/span>
sessions
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>filter(&lt;span style="color:#66d9ef">fn&lt;/span> session &lt;span style="color:#f92672">-&amp;gt;&lt;/span> session_match?(session, params[&lt;span style="color:#e6db74">:search&lt;/span>]) &lt;span style="color:#66d9ef">end&lt;/span>)
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>sort_by(&lt;span style="color:#66d9ef">fn&lt;/span> session &lt;span style="color:#f92672">-&amp;gt;&lt;/span> session[params[&lt;span style="color:#e6db74">:sort_by&lt;/span>]] &lt;span style="color:#66d9ef">end&lt;/span>, params[&lt;span style="color:#e6db74">:sort_dir&lt;/span>])
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> session_match?(_session, &lt;span style="color:#66d9ef">nil&lt;/span>), &lt;span style="color:#e6db74">do&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> session_match?(session, search_string), &lt;span style="color:#e6db74">do&lt;/span>: &lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>contains?(session[&lt;span style="color:#e6db74">:id&lt;/span>], search_string)
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
As outlined above, we start by filtering by search, using a very simple logic that just checks if the session ID contains the searched string.&lt;/p>
&lt;p>
After search, we apply the sorting logic: the values of the &lt;code>:sort_by&lt;/code> and &lt;code>:sort_dir&lt;/code> perfectly fit using &lt;code>Enum.sort_by/3&lt;/code> (a really appreciated API design choice), making the implementation short and sweet.&lt;/p>
&lt;p>
When defining the returning tuple, we take care of applying the limit and returning the correct total count.&lt;/p>
&lt;p>
With these changes in place, the generated table behaves as expected:&lt;/p>
&lt;p>
&lt;img src="http://claudio-ortolina.org/img/building-a-custom-page-for-phoenix-live-dashboard/sessions-table.png" alt="A screenshot of the Spotify sessions table built in this blog post" class="left" />
&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-2">
&lt;h2 id="headline-7">
Supporting multiple nodes
&lt;/h2>
&lt;div id="outline-text-headline-7" class="outline-text-2">
&lt;p>
The last piece of the puzzle is making sure that we take into account the currently selected node.&lt;/p>
&lt;p>
Fortunately, we just need to make a very small change to &lt;code>fetch_sessions/2&lt;/code>:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">defp&lt;/span> fetch_sessions(params, node) &lt;span style="color:#66d9ef">do&lt;/span>
sessions &lt;span style="color:#f92672">=&lt;/span>
node
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#e6db74">:rpc&lt;/span>&lt;span style="color:#f92672">.&lt;/span>call(&lt;span style="color:#a6e22e">Tune.Spotify.Supervisor&lt;/span>, &lt;span style="color:#e6db74">:sessions&lt;/span>, [])
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> filter(params)
{&lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>take(sessions, params[&lt;span style="color:#e6db74">:limit&lt;/span>]), length(sessions)}
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
The OTP &lt;a href="https://erlang.org/doc/man/rpc.html">rpc&lt;/a> module conveniently provides a &lt;a href="https://erlang.org/doc/man/rpc.html#call-4">&lt;code>call/4&lt;/code>&lt;/a> function that takes a node name, module, function, and arguments, returning the exact same value of the remotely executed function.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-2">
&lt;h2 id="headline-8">
Conclusions
&lt;/h2>
&lt;div id="outline-text-headline-8" class="outline-text-2">
&lt;p>
To see the final version of &lt;code>TuneWeb.LiveDashboard.SpotifySessionsPage&lt;/code>, you can open &lt;a href="https://github.com/fully-forged/tune/blob/32038997bc89f94ca8ee18f80d2f1cae946f7acb/lib/tune_web/live_dashboard/spotify_sessions_page.ex">the file in the repo&lt;/a>.&lt;/p>
&lt;/div>
&lt;/div></description></item><item><title>Tips for Finch and Telemetry</title><link>http://claudio-ortolina.org/posts/tips-for-finch-and-telemetry/</link><pubDate>Tue, 17 Nov 2020 17:27:05 +0000</pubDate><guid>http://claudio-ortolina.org/posts/tips-for-finch-and-telemetry/</guid><description>
&lt;p>
While working on &lt;a href="https://github.com/fully-forged/tune">Tune&lt;/a>, I needed to collect performance metrics related to the interaction with the Spotify API.&lt;/p>
&lt;p>
The Finch HTTP client &lt;a href="https://hexdocs.pm/finch/Finch.html#module-telemetry">exposes Telemetry metrics&lt;/a>, which made it very easy to display them via &lt;a href="https://hex.pm/packages/phoenix_live_dashboard">Phoenix Live Dashboard&lt;/a>.&lt;/p>
&lt;p>
Starting from the stock &lt;code>TuneWeb.Telemetry&lt;/code> file generated by Phoenix (see &lt;a href="https://hexdocs.pm/phoenix/telemetry.html#content">the official guides for an explanation&lt;/a>), I just added two new summary metrics to the &lt;code>metrics/0&lt;/code> function:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir"> summary(&lt;span style="color:#e6db74">&amp;#34;vm.total_run_queue_lengths.io&amp;#34;&lt;/span>),
&lt;span style="color:#75715e"># HTTP&lt;/span>
summary(&lt;span style="color:#e6db74">&amp;#34;finch.request.stop.duration&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">unit&lt;/span>: {&lt;span style="color:#e6db74">:native&lt;/span>, &lt;span style="color:#e6db74">:millisecond&lt;/span>}, &lt;span style="color:#e6db74">tags&lt;/span>: [&lt;span style="color:#e6db74">:path&lt;/span>]),
summary(&lt;span style="color:#e6db74">&amp;#34;finch.response.stop.duration&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">unit&lt;/span>: {&lt;span style="color:#e6db74">:native&lt;/span>, &lt;span style="color:#e6db74">:millisecond&lt;/span>}, &lt;span style="color:#e6db74">tags&lt;/span>: [&lt;span style="color:#e6db74">:path&lt;/span>])
]&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
With this change in place (&lt;a href="https://github.com/fully-forged/tune/commit/7c573aa30313a8adf1954076b9cd957f0f910155">commit&lt;/a>), I had all metrics being visualized in the dashboard, grouped by the Spotify API path. I wanted to make some improvements:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The &lt;code>:path&lt;/code> tag includes query string parameters, so calls like &lt;code>search?q=marillion&lt;/code> and &lt;code>search?q=fish&lt;/code> would be aggregated in different groups. Instead, I would want them to be part of the same group, ignoring query string parameters.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Since I &lt;a href="http://claudio-ortolina.org/posts/using-finch-with-sentry/">setup Sentry to use Finch as a client&lt;/a>, I wanted to exclude calls made to Sentry and only have charts reporting metrics about the interaction with Spotify&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
Aggregating by normalized path
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
To aggregate metrics by normalized path, we can apply a transformation function to the metric tag values, generate a normalized path tag and use that to aggregate metrics. As shown &lt;a href="https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#module-metrics">in the telemetry_metrics docs&lt;/a>, the option we need is &lt;code>tag_values&lt;/code>:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">def&lt;/span> metrics &lt;span style="color:#66d9ef">do&lt;/span>
[
&lt;span style="color:#75715e"># omitted&lt;/span>
summary(&lt;span style="color:#e6db74">&amp;#34;finch.request.stop.duration&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">unit&lt;/span>: {&lt;span style="color:#e6db74">:native&lt;/span>, &lt;span style="color:#e6db74">:millisecond&lt;/span>},
&lt;span style="color:#e6db74">tags&lt;/span>: [&lt;span style="color:#e6db74">:normalized_path&lt;/span>],
&lt;span style="color:#e6db74">tag_values&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>add_normalized_path&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
)
]
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> add_normalized_path(metadata) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#a6e22e">Map&lt;/span>&lt;span style="color:#f92672">.&lt;/span>put(metadata, &lt;span style="color:#e6db74">:normalized_path&lt;/span>, &lt;span style="color:#a6e22e">URI&lt;/span>&lt;span style="color:#f92672">.&lt;/span>parse(metadata&lt;span style="color:#f92672">.&lt;/span>path)&lt;span style="color:#f92672">.&lt;/span>path)
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
We can use the built-in &lt;code>URI&lt;/code> module to parse normalized path out of the Finch metric metadata and add it to the metadata itself. With that in place, we can update the &lt;code>tags&lt;/code> option to reference &lt;code>:normalized_path&lt;/code>. With this change, metrics are aggregated on the endpoint only, without any query string. For reference, here&amp;#39;s the relevant &lt;a href="https://github.com/fully-forged/tune/commit/8ab6fab59357e97579ac086a94e768193c2872a5?branch=8ab6fab59357e97579ac086a94e768193c2872a5&amp;amp;diff=unified">commit&lt;/a>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-2" class="outline-2">
&lt;h2 id="headline-2">
Filtering only Spotify calls
&lt;/h2>
&lt;div id="outline-text-headline-2" class="outline-text-2">
&lt;p>
To filter for Spotify calls only, we can use the &lt;code>keep&lt;/code> option, which specifies a predicate function that can be used to define which metrics should be kept and which ones should be discarded. Discarded metrics will not appear in the dashboard chart.&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">def&lt;/span> metrics &lt;span style="color:#66d9ef">do&lt;/span>
[
&lt;span style="color:#75715e"># omitted&lt;/span>
summary(&lt;span style="color:#e6db74">&amp;#34;finch.response.stop.duration&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">unit&lt;/span>: {&lt;span style="color:#e6db74">:native&lt;/span>, &lt;span style="color:#e6db74">:millisecond&lt;/span>},
&lt;span style="color:#e6db74">tags&lt;/span>: [&lt;span style="color:#e6db74">:normalized_path&lt;/span>],
&lt;span style="color:#e6db74">tag_values&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>add_normalized_path&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,
&lt;span style="color:#e6db74">keep&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>keep_spotify&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,
&lt;span style="color:#e6db74">reporter_options&lt;/span>: [
&lt;span style="color:#e6db74">nav&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;HTTP - Spotify&amp;#34;&lt;/span>
]
)
]
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> keep_spotify(meta) &lt;span style="color:#66d9ef">do&lt;/span>
meta&lt;span style="color:#f92672">.&lt;/span>host &lt;span style="color:#f92672">=~&lt;/span> &lt;span style="color:#e6db74">&amp;#34;spotify&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
As the meta information already includes a host, we can compare it with the &lt;code>spotify&lt;/code> string. The &lt;code>=~&lt;/code> operator makes the comparison a bit more resilient, so that we don&amp;#39;t have to worry about the exact hostname, rather a hostname related to Spotify. This choice might need to be revised if we ever end up interacting via HTTP with another service with &amp;#34;spotify&amp;#34; in their host name (unlikely, but possible).&lt;/p>
&lt;p>
For some additional clarity, we can also use the &lt;code>nav&lt;/code> reporter option (see &lt;a href="https://hexdocs.pm/phoenix_live_dashboard/metrics.html#reporter-options">Phoenix LiveDashboard documentation&lt;/a> for more details) to make sure that the navigation header displays a name that details the additional filter applied to the HTTP metrics. For reference, see the relevant &lt;a href="https://github.com/fully-forged/tune/commit/c9f483d93c0813c0e680a4aaf2a88fed0851334f#diff-f599bf85f0cafc16b50f0e1a561b6aa39e4ab256fb6d43e8726619570866c5b1">commit&lt;/a>.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-2">
&lt;h2 id="headline-3">
Conclusion
&lt;/h2>
&lt;div id="outline-text-headline-3" class="outline-text-2">
&lt;p>
Both improvements required very small updates. Here&amp;#39;s the final result, showing the custom Nav title (&amp;#34;HTTP - Spotify&amp;#34;) to hint at the filter used to only show Spotify calls, and aggregation by normalized path (without query string).&lt;/p>
&lt;p>
&lt;img src="http://claudio-ortolina.org/img/tips-for-finch-and-telemetry/charts.png" alt="A screenshot of the configured Finch Metrics inside Live Dashboard" class="left" />
&lt;/p>
&lt;p>
All in all, I was pleased to see that it was straightforward to customise the charts I needed. One thing I haven&amp;#39;t worked on yet is aggregating metrics by logical path, i.e. by route (&lt;code>GET /artist/:id&lt;/code>) instead of individual paths (&lt;code>GET /artist/123&lt;/code>), but I have some ideas and will come back on it in a future post.&lt;/p>
&lt;/div>
&lt;/div></description></item><item><title>Using Finch With Sentry</title><link>http://claudio-ortolina.org/posts/using-finch-with-sentry/</link><pubDate>Tue, 10 Nov 2020 08:41:30 +0000</pubDate><guid>http://claudio-ortolina.org/posts/using-finch-with-sentry/</guid><description>
&lt;p>
A few weeks ago I added enabled support for &lt;a href="https://sentry.io">Sentry&lt;/a> inside &lt;a href="https://github.com/fully-forged/tune">Tune&lt;/a>, my Spotify browser/client. Even if I&amp;#39;m pretty much the only user (I built it for myself after all), having exception tracking has already proved to be useful - band and song names can really create all sorts of issues.&lt;/p>
&lt;p>
The &lt;a href="https://hex.pm/packages/sentry">official Sentry package&lt;/a> works as advertised and by default it communicates using &lt;a href="https://hex.pm/packages/hackney">Hackney&lt;/a> as a http client. As I&amp;#39;ve been using &lt;a href="https://hex.pm/packages/finch">Finch&lt;/a> in the project, I was pleased to see that Sentry exposed a &lt;code>client&lt;/code> configuration option that allowed using your own module, as long as it implemented the &lt;code>Sentry.HTTPClient&lt;/code> behaviour.&lt;/p>
&lt;p>
The advantage in swapping the http client library (on top of uniforming the building blocks of the application) is that Finch has support for &lt;a href="https://hex.pm/packages/telemetry">Telemetry&lt;/a> metrics.&lt;/p>
&lt;blockquote>
&lt;p>Update #1: Thanks to Wojtek Mach for &lt;a href="https://github.com/fully-forged/tune/pull/131">a more streamlined implementation.&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>
The module I wrote is quite short:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">Sentry.FinchClient&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#a6e22e">@moduledoc&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> Defines a small shim to use `Finch` as a `Sentry.HTTPClient`.
&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">@behaviour&lt;/span> &lt;span style="color:#a6e22e">Sentry.HTTPClient&lt;/span>
&lt;span style="color:#a6e22e">@impl&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> child_spec &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#a6e22e">Finch&lt;/span>&lt;span style="color:#f92672">.&lt;/span>child_spec(&lt;span style="color:#e6db74">name&lt;/span>: &lt;span style="color:#a6e22e">Sentry.Finch&lt;/span>)
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#a6e22e">@impl&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> post(url, headers, body) &lt;span style="color:#66d9ef">do&lt;/span>
request &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Finch&lt;/span>&lt;span style="color:#f92672">.&lt;/span>build(&lt;span style="color:#e6db74">:post&lt;/span>, url, headers, body)
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">Finch&lt;/span>&lt;span style="color:#f92672">.&lt;/span>request(request, &lt;span style="color:#a6e22e">Sentry.Finch&lt;/span>) &lt;span style="color:#66d9ef">do&lt;/span>
{&lt;span style="color:#e6db74">:ok&lt;/span>, response} &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
{&lt;span style="color:#e6db74">:ok&lt;/span>, response&lt;span style="color:#f92672">.&lt;/span>status, response&lt;span style="color:#f92672">.&lt;/span>headers, response&lt;span style="color:#f92672">.&lt;/span>body}
error &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
error
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
The trickiest bit was to get the &lt;code>child_spec/0&lt;/code> callback right while keeping &lt;a href="https://erlang.org/doc/man/dialyzer.html">dialyzer&lt;/a> happy. The first implementation I wrote was simply &lt;code>{Finch, name: Sentry.Finch}&lt;/code>, but that would fail to satisfy &lt;a href="https://hexdocs.pm/sentry/Sentry.HTTPClient.html#c:child_spec/0">the typespec defined for &lt;code>child_spec/0&lt;/code>&lt;/a>. I then switched to a more verbose version:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir"> &lt;span style="color:#66d9ef">def&lt;/span> child_spec &lt;span style="color:#66d9ef">do&lt;/span>
opts &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">name&lt;/span>: &lt;span style="color:#a6e22e">Sentry.Finch&lt;/span>]
&lt;span style="color:#a6e22e">Supervisor&lt;/span>&lt;span style="color:#f92672">.&lt;/span>child_spec(
%{
&lt;span style="color:#e6db74">id&lt;/span>: __MODULE__,
&lt;span style="color:#e6db74">start&lt;/span>: {&lt;span style="color:#a6e22e">Finch&lt;/span>, &lt;span style="color:#e6db74">:start_link&lt;/span>, [opts]},
&lt;span style="color:#e6db74">type&lt;/span>: &lt;span style="color:#e6db74">:supervisor&lt;/span>
},
[]
)
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
This version satisfied dialyzer, but turns out there&amp;#39;s a simpler way. After publishing this blog post, Wojtek Mach reached out and submitted a PR to streamline the specification to the version shown in the full example above.&lt;/p>
&lt;p>
I also updated my production configuration:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">config &lt;span style="color:#e6db74">:sentry&lt;/span>,
&lt;span style="color:#e6db74">dsn&lt;/span>: {&lt;span style="color:#e6db74">:system&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SENTRY_DSN&amp;#34;&lt;/span>},
&lt;span style="color:#e6db74">environment_name&lt;/span>: &lt;span style="color:#e6db74">:prod&lt;/span>,
&lt;span style="color:#e6db74">enable_source_code_context&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;span style="color:#e6db74">root_source_code_path&lt;/span>: &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>cwd!(),
&lt;span style="color:#e6db74">client&lt;/span>: &lt;span style="color:#a6e22e">Sentry.FinchClient&lt;/span>,
&lt;span style="color:#e6db74">included_environments&lt;/span>: [&lt;span style="color:#e6db74">:prod&lt;/span>]&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
You can of course expand on this implementation if you need to pass more options to the &lt;code>Finch&lt;/code> child specification - I found that for my use case, defaults are fine, so for now I don&amp;#39;t need to add any configuration hooks.&lt;/p>
&lt;p>
To see the change in context, &lt;a href="https://github.com/fully-forged/tune/pull/122">this is the original PR&lt;/a>, with the &lt;a href="https://github.com/fully-forged/tune/pull/131">follow-up by Wojtek Mach&lt;/a>.&lt;/p></description></item><item><title>A Short Profiling Story</title><link>http://claudio-ortolina.org/posts/a-short-profiling-story/</link><pubDate>Tue, 03 Nov 2020 11:42:42 +0000</pubDate><guid>http://claudio-ortolina.org/posts/a-short-profiling-story/</guid><description>
&lt;p>
While transcribing
&lt;a href="https://www.elixirconf.eu/talks/The-Perils-of-Large-Files/">the talk I
gave at the last ElixirConf.eu&lt;/a> conference, one of my colleagues
pointed out that I glossed over the details of one of the examples. This
prompted me to do some digging and I want to share what I found.&lt;/p>
&lt;div id="outline-container-the-problem" class="outline-3">
&lt;h3 id="the-problem">
The problem
&lt;/h3>
&lt;div id="outline-text-the-problem" class="outline-text-3">
&lt;p>
The example in question is a module responsible to fetch a file from a
remote source and write it at the specified path.&lt;/p>
&lt;p>
The implementation is very simplistic and lacks both error handling and
retry logic.&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir"> &lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">Perils.Examples.Store&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> write(file_name, url) &lt;span style="color:#66d9ef">do&lt;/span>
with {&lt;span style="color:#e6db74">:ok&lt;/span>, data} &lt;span style="color:#f92672">&amp;lt;-&lt;/span> get(url) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write!(file_name, data)
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">defp&lt;/span> get(url) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#e6db74">:httpc&lt;/span>&lt;span style="color:#f92672">.&lt;/span>request(&lt;span style="color:#e6db74">:get&lt;/span>, {&lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>to_charlist(url), []}, [], [])
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
{&lt;span style="color:#e6db74">:ok&lt;/span>, result} &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
{{_, &lt;span style="color:#ae81ff">200&lt;/span>, _}, _headers, body} &lt;span style="color:#f92672">=&lt;/span> result
{&lt;span style="color:#e6db74">:ok&lt;/span>, body}
error &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
error
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
Looking at the code, we can see that it relies on &lt;code class="verbatim">:httpc&lt;/code>, the http
client that ships with Erlang/OTP.&lt;/p>
&lt;p>
Both in my talk and in the initial transcription draft, I pointed out
that running this code with a 12MB file would result in a memory usage
peak at around 350/375MB, but didn&amp;#39;t really look into why.&lt;/p>
&lt;p>
&lt;img src="http://claudio-ortolina.org/img/a-short-profiling-story/before.png" alt="A chart visualizing a 350MB memory spike" class="left" />
&lt;/p>
&lt;p>
Such delta between the file size and peak memory usage is suspicious and
worth investigating.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-the-investigation" class="outline-3">
&lt;h3 id="the-investigation">
The investigation
&lt;/h3>
&lt;div id="outline-text-the-investigation" class="outline-text-3">
&lt;p>
I started by setting up an &lt;a href="https://github.com/parroty/exprof">exprof&lt;/a>
test, so that I could profile resource usage associated with the
problematic function.&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir"> &lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#a6e22e">ExProf.Macro&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> run(url) &lt;span style="color:#66d9ef">do&lt;/span>
profile &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#a6e22e">Perils.Examples.Store&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;magazine.pdf&amp;#34;&lt;/span>, url)
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://web-examples.pspdfkit.com/magazine/example.pdf&amp;#34;&lt;/span> &lt;span style="color:#75715e">#12MB&lt;/span>
{records, _block_result} &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>&lt;span style="color:#f92672">.&lt;/span>run(url)
total_percent &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>reduce(records, &lt;span style="color:#ae81ff">0.0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>(&amp;amp;1&lt;span style="color:#f92672">.&lt;/span>percent &lt;span style="color:#f92672">+&lt;/span> &amp;amp;2))
&lt;span style="color:#a6e22e">IO&lt;/span>&lt;span style="color:#f92672">.&lt;/span>inspect(&lt;span style="color:#e6db74">&amp;#34;total = &lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>total_percent&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
The result (with some lines omitted) shows that most of the time
(51.74%) is spent converting the binary response body to a list inside
the &lt;code class="verbatim">maybe_format_body/2&lt;/code> function:&lt;/p>
&lt;pre class="example">
FUNCTION CALLS % TIME [uS / CALLS]
-------- ----- ------- ---- [----------]
&amp;lt;omitted&amp;gt;
erlang:iolist_to_binary/1 1 20.46 49705 [ 49705.00]
erlang:binary_to_list/1 1 27.54 66887 [ 66887.00]
httpc:maybe_format_body/2 1 51.74 125664 [ 125664.00]
&lt;/pre>
&lt;p>
While this is not an indication of higher memory usage per se, it&amp;#39;s a
good lead: binary to list conversion can be memory intensive.&lt;/p>
&lt;p>
I then looked at the
&lt;a href="https://github.com/erlang/otp/blob/3f21ce1e6a5d6c548867fa4bc9a8c666c626ade1/lib/inets/src/http_client/httpc.erl#L655-L661">source
for &lt;code class="verbatim">maybe_format_body/2&lt;/code>&lt;/a>, making sure to match on the OTP version I
tested against (23.1.1).&lt;/p>
&lt;div class="src src-erlang">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-erlang" data-lang="erlang"> maybe_format_body(BinBody, Options) &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">case&lt;/span> proplists:&lt;span style="color:#a6e22e">get_value&lt;/span>(body_format, Options, string) &lt;span style="color:#66d9ef">of&lt;/span>
string &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
binary_to_list(BinBody);
_ &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
BinBody
&lt;span style="color:#66d9ef">end&lt;/span>.&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
As expected, the function uses &lt;code class="verbatim">binary_to_list/1&lt;/code> to transform the
response binary body into a list. Luckily, this behaviour can be tweaked
via the &lt;code class="verbatim">body_format&lt;/code> option, which defaults to &lt;code class="verbatim">string&lt;/code> (as in Erlang
string, which maps to a character list in Elixir).&lt;/p>
&lt;p>
Searching for &lt;code class="verbatim">body_format&lt;/code> in
&lt;a href="http://erlang.org/doc/man/httpc.html#request-5">the Erlang docs for
&lt;code class="verbatim">request/5&lt;/code>&lt;/a> shows that indeed it&amp;#39;s possible to tweak our problematic
implementation to:&lt;/p>
&lt;div class="src src-elixir">
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir"> &lt;span style="color:#e6db74">:httpc&lt;/span>&lt;span style="color:#f92672">.&lt;/span>request(&lt;span style="color:#e6db74">:get&lt;/span>, {&lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>to_charlist(url), []}, [], &lt;span style="color:#e6db74">body_format&lt;/span>: &lt;span style="color:#e6db74">:binary&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
With this change, memory usage decreases dramatically, showing a delta
only slightly larger than the file size.&lt;/p>
&lt;p>
&lt;img src="http://claudio-ortolina.org/img/a-short-profiling-story/after.png" alt="A chart visualizing a 15MB memory spike" class="left" />
&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-conclusion" class="outline-3">
&lt;h3 id="conclusion">
Conclusion
&lt;/h3>
&lt;div id="outline-text-conclusion" class="outline-text-3">
&lt;p>
This whole investigation got me thinking, as the &lt;code class="verbatim">body_format&lt;/code> option
had been in the docs all along, yet I hadn&amp;#39;t seen it. I can find three
reasons:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The overall logic in the example doesn&amp;#39;t really care about the
response body contents, as it just writes them to a file. Without
seeing that response, there was no way for me to even notice its
type.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code class="verbatim">File.write/2&lt;/code> accepts binaries, strings and character lists - again
I didn&amp;#39;t have a reason to even wonder about the type used to
represent that returned response body.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Working primarily in Elixir, everything tends to be either a string
or a binary. I just &amp;#34;forget&amp;#34; that character lists exist, which lead
to the implicit assumption that this would be the default for
&lt;code class="verbatim">:httpc&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In other words, I didn&amp;#39;t know what to search in the docs. Profiling
tools helped me understand the problem space and pointed me in the right
direction.&lt;/p>
&lt;/div>
&lt;/div></description></item></channel></rss>